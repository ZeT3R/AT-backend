import pandas as pd

trues = {
    'a': ['1', '0', '0', '0', '1', '1', '0', '0', '1', '1'],  # Истинные значения для a
    'b': ['1', '0', '1', '1', '0', '1', '0', '1', '1', '1'],  # Истинные значения для b
    'c': ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1'],  # Истинные значения для c
    'd': ['1', '1', '0', '0', '1', '1', '1', '0', '1', '0'],  # Истинные значения для d
    'e': ['1', '0', '1', '0', '0', '1', '1', '0', '1', '0'],  # Истинные значения для e
    'f': ['1', '0', '0', '0', '0', '0', '1', '1', '1', '0'],  # Истинные значения для f
    'g': ['0', '0', '0', '1', '1', '1', '1', '0', '1', '1'],  # Истинные значения для g
    'l': ['0', '1', '0', '1', '0', '0', '1', '1', '0', '0'],  # Истинные значения для l
    'm': ['0', '0', '1', '1', '0', '0', '0', '0', '0', '1']  # Истинные значения для m
}


def create_var(b, offset, seg):  # Функция создания таблицы под определённый вариант
    dataframe = pd.DataFrame(trues)
    # Словарь со значениями x1-x4. Он всегда будет одинаковым.
    ix = {'x1': ['0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1'],
          'x2': ['0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '1', '1', '1', '1'],
          'x3': ['0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1'],
          'x4': ['0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1']}
    target = {seg: []}  # Создаём словарик, в нём ключ b и не записываем туда значения
    for i in range(offset):  # От 0 до значения смещения
        target[seg].append('x')  # Запихиваем иксы (это как раз смещение от начала, зависит от варианта)
    for i in range(len(b)):  # После этого мы
        target[seg].append(b[i])  # Запихиваем в словарик все значения по варианту. В данном случае b_true
    while len(target[seg]) != 16:  # Если после всех махинаций, у нас есть пустые значения, то
        target[seg].append('x')  # Дозаполняем их иксами
    final = pd.DataFrame.from_dict(ix)  # Создаём датафрейм из словаря с иксами
    final[seg] = target[seg]  # Создаём новый столбец из нашего словаря по варианту
    return final  # И возвращаем


def modify_str(func, t_func):  # Функция изменения строки. Меняет нули и единицы на буквенные обозначения
    func = list(func)  # Переводим функцию в список
    if t_func == 'SDNF':  # Если СДНФ
        for i in range(4):  # 4 терма
            if func[i] == '0':  # Если у нас нолик, то
                func[i] = ' nx' + str(i + 1) + ' ^'  # Пишем не икс i+1. У нас же с нуля, а там с x1.
            else:  # Иначе, если у нас 1
                func[i] = ' x' + str(i + 1) + ' ^'  # Просто икс. В конце добавляем знак умножения
    else:  # Если же СКНФ
        for i in range(4):  # 4 терма
            if func[i] == '0':  # Если ноль
                func[i] = ' nx' + str(i + 1) + ' v'  # Делаем то же самое, ибо мы развернули заранее
            else:  # Если 1
                func[i] = ' x' + str(i + 1) + ' v'  # То же самое, что и СДНФ, только в конце знак сложения

    func = ''.join(func)  # Переводим в строку
    return func  # Возвращаем


def modify_var(var_table, offset, seg):  # Функция модификации таблицы (добавления столбцов и их заполнение)
    SDKNF = {'SDNF': [], 'SKNF': []}  # Создаём словари для функций
    Fsdnf, Fsknf = [], []  # Создаём списки для возврата значения, как по методичке
    for i in range(16):  # 16 строк у нас всего. ИЗначально их надо заполнить прочерками (-)
        SDKNF['SDNF'].append('-')  # Заполняем
        SDKNF['SKNF'].append('-')  # Заполняем
    var_table['SDNF'] = SDKNF['SDNF']  # Впихиваем в таблицу
    var_table['SKNF'] = SDKNF['SKNF']  # Впихиваем в таблицу
    func = ''  # Наша функция СДНФ/СКНФ
    func_list_DNF = []
    func_list_KNF = []
    for i in range(offset, offset + 10):  # Идём от конца смещения до смещения + 10 (Ибо 10 значений)
        if var_table[seg][i] == '1':  # Если в столбце seg у нас стоит 1, значит
            # Значит, что у нас СДНФ столбец заполнять надо. Мы присваиваем функции значения
            # столбцов x1, x2, x3, x4 так, как они есть, те же цифры
            func = str(var_table['x1'][i]) + str(var_table['x2'][i]) + str(var_table['x3'][i]) \
                   + str(var_table['x4'][i])
            func_list_DNF.append(func)
            func = modify_str(func, 'SDNF')  # Запихиваем в функцию изменения строки
            func = list(func)  # Снова преобразовываем в список
            func.pop()  # Вытаскиваем последний элемент, то есть v
            func.append(")")  # Добавляем в конец закрывающую скобку
            func.insert(0, '(')  # И в начало добавляем открывающую скобку
            func = ''.join(func)  # Снова переводим в строку
            var_table.at[i, 'SDNF'] = func  # Ставим строку значением в нашем столбце
            Fsdnf.append(func)  # И добавляем в массив полной функции СДНФ
        else:  # Если же у нас нолик в столбце b, то
            # То значит, что у нас СКНФ вступает в бой. Здесь нужно предварителньо инвертировать
            # значения, чтобы получить правильный результат. Изначально пихаем обычные значения
            func = str(var_table['x1'][i]) + str(var_table['x2'][i]) + str(var_table['x3'][i]) \
                   + str(var_table['x4'][i])
            func_list_KNF.append(func)
            func = list(func)  # Переводим в список
            for j in range(4):  # 4 терма
                if (func[j] == '0'):  # Если был 0
                    func[j] = '1'  # Станет 1
                else:  # Если была 1
                    func[j] = '0'  # Станет 0
            func = modify_str(func, 'SKNF')  # Преобразовываем строку
            func = list(func)  # Снова в список
            func.pop()  # Вытаскиваем лишний символ
            func.append(")")  # Добавляем в конец закрывающую скобку
            func.insert(0, '(')  # И в начало добавляем открывающую скобку
            func = ''.join(func)  # Снова в строку
            var_table.at[i, 'SKNF'] = func  # Добавляем значение в таблицу
            Fsknf.append(func)  # И прибавляем в финальный список функции СКНФ
    return var_table, Fsdnf, Fsknf, func_list_DNF, func_list_KNF